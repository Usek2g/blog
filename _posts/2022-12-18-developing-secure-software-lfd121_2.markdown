---
layout: post
title:  "Linux Foundationの「セキュアソフトウェア開発」を受講しました（2）"
date:   2022-12-24 20:50:27 +0900
categories: online-training
img: lfd121-jp.png # Add image post (optional)
tags: [security] # add tag
description: Linux Foundationの「セキュアソフトウェア開発」を受講しました
---

[Linux Foundation「セキュア ソフトウェア開発」無料オンラインコースを開始](https://www.linuxfoundation.jp/press-release/2022/12/free-openssf-developing-secure-software-training-course-now-available-in-japanese/)
第2部の内容についての所感です。
自分用のメモが含まれているため、理解度テストの結果が含まれています。ネタバレを防ぐため、受講する人は先に受講してからこの記事を読んでほしいです。

# 「第2部：実装」
バリデーション（コーディングによる機械的な値チェック）、バリデーションの先の値チェック（メモリ境界外読み取り/書き込み/解放、変数の型のオーバーフロー）、実装でのコーディングミス、

符号なし型とかUnicodeとか、知識があいまいな部分について再認識ができました。
バリデーションと一言に行っても、単に数値やテキストを超え、テキストエンコーディングやデシアライゼーション、外部参照、環境変数の利用など考えることが多いです。csvファイル自体に書かれているのは単純な文字列でも、Excelで開いた場合に「=」が使われていると関数とみなして実行するなど、言われてみると「そういえばそうだ」という話も多く掲載されています。
バリデーションや値チェックなど不正な入力値をチェックできても、人間が意図せず作りこんだプログラムのバグまではチェックできません。
CVE-2014-1266、通称「goto fail; goto fail;」脆弱性（https://appllio.com/20140223-4899-apple-ios-bug-ssl-goto-fail）など、ぞっとする話ですが同時にやりかねない話だと思います。

> 歴史的には、すべての文字を識別するには16ビットで十分だと考えられていましたが、これは間違いで、1996年に変更されました（現在はどの文字も21ビットで符号化するようになっています）。この間違いの結果、一部のプログラミング言語は、16ビット長しかない「文字」型（Javaのcharなど）を持っています。16ビットのデータ型は、それ自体では21ビットの任意の文字を格納できないため、16ビットの「文字」を持つプログラミング言語やAPIでは、「文字」が実際の文字の半分しかないことがあります。

理解度テストの7.4、**許可リストにするには^...$が必要**って「そうなの？」という感想でした。
`^`が文頭を、`$`が文末を意味するのは知っているのですが、`[a-z]+` で1文字以上の小文字英字を意味しないの？
`^[a-z]+$`でないとダメなのかな？だとすると、正規表現を使う場合`^`が文頭を、`$`が文末の意味をあらわすのは知っていましたが、これは必須なのでしょうか？（章最期のナレッジテストでもそれに従ったら正解になったので、そういうものなのかもしれない）

脆弱な正規表現というものを初めて知りました。下手なマッチングを書いたせいで処理に時間がかかり、結果自分からDoSを自分のシステムにしかけるというものです。正規表現は自分も十分理解しているとは言えないため怖いところです。setuid/setgidが絡むプログラムは極力書きたくないという感想も持ちました。とはいえ触らぬ神に祟りなしの姿勢はエンジニアとして正しいのか・・・、
APIの使用回数制限ややネットワーク帯域の帯域制限など、単純ながら攻撃者に攻撃を躊躇させる（あるいはプログラムの予期せぬバグに対する防波堤になる）対策があることも頭の片隅に入れておきたいです。


デシアライゼーションについてはこちらのページが参考になりました。
https://yamory.io/blog/about-insecure-deserialization/

yamoryさんはXXE（XML External Entity: XML 外部エンティティ参照, XML 外部実体）についても解説してくれています。
https://yamory.io/blog/what-is-xxe/


バリデーションの章を〆るナレッジチェック（テスト）はかなり難度が高いです。でも7.2の問題は納得がいかない…日本語だとAとCは同じ意味に聞こえるんですよね。原文（英語）だと違う意味ととらえられるのでしょうか。他にも第2部は解説の日本語が腑に落ちない箇所が散見しました。カリキュラムに書かれていないことも問われるので、地頭が必要になる部分もあります。

> (メモリーセーフでない)CやC++で書かれた大規模なプログラムには、書き換えが困難なものがたくさんありますし、もちろん、人々がそれらの言語を選択する理由もあります。オペレーティングシステムのカーネルはほとんどがCで書かれていますが、これはパフォーマンスが重要であり、Cがこの作業のために特別に設計されたからです。同様に、メモリー安全性を無効にできる言語にも、そのメカニズムが存在する理由があるのです。

CやC++においてメモリ解放が重要なのは承知ですが、解放された後のメモリを再利用することはリスクがあると学びました。
https://www.jpcert.or.jp/sc-rules/c-mem30-c.html
https://www.comp.sd.tmu.ac.jp/spacelab/c_lec2/node118.html
しかしメモリ容量には限度があります。メモリを使いきってしまった、ということにはならないのでしょうか？（頓珍漢な疑問？）

CやC++における[未定義の動作](https://programming-place.net/ppp/contents/glossary/ma/undefined_behavior.html)

自分用メモ
- セキュアな入力検証チェックは「なにがNGか」ではなく「なにのみがOKか」で設定を行う
- 電子メールだけを用いたパスワードのリセットは、攻撃者によるものの可能性があるため、強力な認証メカニズムではない。
- ほとんどのUnix系システムにおいて、ファイル名は\0（終端記号）やスラッシュを含まない任意のバイト列とすることができる。Unixのファイル名は文字列ではなく、単なるバイト列なので、ファイル名は必ずしも正規の文字列である必要はない。スペース（またはスペースだけ）、制御文字（改行、タブ、エスケープなどを含む）、UTF-8の適正でないバイト、または、先頭の「-」（コマンドオプションの目印）を含むファイル名などの多くの問題のあるファイル名を作成することができる

NGなプリペアードステートメント
```
String QueryString = "select * from authors where lastname = '" + search_lastname + "';";
PreparedStatement pstmt = connection.prepareStatement(QueryString);
ResultSet results = pstmt.execute( ); // Probably insecure, don’t do this!
```

OKなプリペアードステートメント
```
String QueryString = "select * from authors where lastname = ?";
PreparedStatement pstmt = connection.prepareStatement(QueryString);
pstmt.setString(1, search_lastname);
ResultSet results = pstmt.execute( );
```

>「?」を値のプレースホルダーとして正しく使用する代わりに（その後適切にエスケープされます）、このコードはデータをクエリーに直接連結しています。このデータが適切にエスケープされていない限り（そして、ほぼ間違いなくされていません）、このコードは、このデータが攻撃者によって制御される場合、すぐに深刻な脆弱性につながる可能性があります。

→JavaにおけるprepareStatementの使い方を覚える